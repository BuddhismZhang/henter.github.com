<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Henter</title>
 <link href="http://henter.me/atom.xml" rel="self"/>
 <link href="http://henter.me"/>
 <updated>2013-03-29T12:01:04+08:00</updated>
 <id>http://henter.me/</id>
 <author>
   <name>Henter</name>
 </author>

 
 <entry>
   <title>通过dotcloud代替localtunnel建立本地服务器</title>
   <link href="//2013/03/22/local-webapp-to-the-web-with-dotcloud.html"/>
   <updated>2013-03-22T00:00:00+08:00</updated>
   <id>/2013/03/22/local-webapp-to-the-web-with-dotcloud</id>
   <content type="html">&lt;p&gt;安装dotcloud cli&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo easy_install pip &amp;amp;&amp;amp; sudo pip install dotcloud

dotcloud setup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS：我按以上步骤安装完后 &lt;code&gt;dotcloud&lt;/code&gt;不能直接用&lt;/p&gt;

&lt;p&gt;需要用 &lt;code&gt;/usr/local/share/python/dotcloud&lt;/code&gt;代替&lt;/p&gt;

&lt;p&gt;当然，你也可以用软链&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /usr/local/share/python/dotcloud /usr/local/bin/dotcloud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完dotcloud cli工具后，开始建立webapp，以&lt;code&gt;webtunnel&lt;/code&gt;为例&lt;/p&gt;

&lt;p&gt;先从github clone一个配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/3on/tunnel-on-dotcloud.git
cd tunnel-on-dotcloud/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：这个repo里面有个地方写错了，默认是无法直接运行的，修改如下&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;www/nginx.conf&lt;/code&gt;文件，在root这一行（第7行）尾部加一个分号&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dotcloud create webtunnel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会提示&lt;code&gt;Connect the current directory to &quot;webtunnel&quot;?&lt;/code&gt;，是否以当前目录做为app目录
也可以用下面这个命令手动执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dotcloud connect webtunnel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，push到dotcloud服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dotcloud push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开 http://webtunnel-你的用户名.dotcloud.com&lt;/p&gt;

&lt;p&gt;部署成功的话会显示 &lt;code&gt;www/index.html&lt;/code&gt;的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Grab host url


    dotcloud info tunnel.proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果提示“Application Not Responding”，表示部署失败，检查问题重新部署。&lt;/p&gt;

&lt;p&gt;然后，查看proxy信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`dotcloud info proxy`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过程如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜$ dotcloud info proxy
== proxy
type:            static
instances:       1
reserved memory: N/A
URLs:
  - http://webtunnel-henter.dotcloud.com

=== proxy.0
datacenter:       Amazon-us-east-1d
service revision: static/da4d1ea2eec9 (latest revision)
revision:         rsync-1363850353553
ports:
  ssh: ssh://dotcloud@webtunnel-henter.azva.dotcloud.net:22481
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启本地服务器，如果没安装apache nginx等web服务器，可以用python开启一个简易服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，通过ssh链接dotcloud，注意连接格式把里面的host和8000（本地web服务器端口）改成你自己的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -i ~/.dotcloud_cli/dotcloud.key -l dotcloud -p 22481 webtunnel-henter.azva.dotcloud.net -R 8042:localhost:8000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://blog.dotcloud.com/open-your-local-webapp-to-the-web-with-dotclo
https://github.com/3on/tunnel-on-dotcloud
http://docs.dotcloud.com/guides/flavors/
http://docs.dotcloud.com/firststeps/install/
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Cubieboard开发版测试</title>
   <link href="//cubieboard/2013/03/21/Cubieboard-test.html"/>
   <updated>2013-03-21T21:11:26+08:00</updated>
   <id>/cubieboard/2013/03/21/Cubieboard-test</id>
   <content type="html">&lt;p&gt;安装VNC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install tightvncserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改xstartup文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/.vnc/xstartup
输入以下内容
    #!/bin/sh
    startlubuntu &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动VNC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tightvncserver -geometry 800x600 :1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果首次启动，输入vncpasswd设置密码&lt;/p&gt;

&lt;p&gt;PS：可以将启动命令加入/etc/rc.local开机启动。&lt;/p&gt;

&lt;p&gt;关闭VNC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tightvncserver -kill :1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完后可以直接这Windows下连接VNC（通过VNC Viewer）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>尝试一下FarBox的服务</title>
   <link href="//2013/02/06/try-farbox.html"/>
   <updated>2013-02-06T00:00:00+08:00</updated>
   <id>/2013/02/06/try-farbox</id>
   <content type="html">&lt;p&gt;一直想搭建一个自己的博客，所谓好记性不如烂博客，但是貌似几年过去了，还是不了了之。&lt;/p&gt;

&lt;p&gt;分别经历了以下过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;虚拟主机，安装博客程序
搭建VPS
用第三方服务，点点网
用云平台，新浪SAE
用Github
最终，选择了现在的Farbox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用虚拟主机&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;需要自己安装程序，各种配置，修改模板等等
最蛋疼的是，服务商如果不靠谱，就随时可能杯具，数据都拿不回来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用VPS&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;除了上面的问题，还要自己配置服务器，做数据备份，小心翼翼。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用第三方&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不怎么靠谱，能省去上面提到的各种繁琐问题，但是无法充分定制，数据也拿不回来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用云平台&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;比较靠谱，但是SAE需要云豆支持，虽然不贵，但是万一没云豆了，不续费就会被删掉。
另外，在本地调试SAE程序也比较蛋疼，需要安装模拟服务器。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用Github&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;靠谱，很多人用这个，我最开始也一直想用。
优点是可以通过Git发布、免费、平台稳定、可定制模板、可以直接用Markdown写文章、无需数据库等等。
缺点是，只能是静态页面，不过通过Jekyll配合生成静态页还是很爽的。
问题也来了，由于需要用到Jekyll（基于Ruby），像我这样目前大多数时间都在Windows平台的用户来说，安装Jeklly还是比较复杂。
期间甚至想过用PHP来解析Markdown然后生成静态页发布到Git，但是如果这样的话，就又需要面对第1、2种方式的各种问题了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用Farbox&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;最终，一次偶然的机会，在V2EX发现了Farbox，立马就兴奋了！
静态页
无需数据库
结合云存储平台（Dropbox、快盘）
定制模板
简单易用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这正是完全符合我需求的博客平台，我自己本身是快盘重度用户，之前在SAE或Github搭建时，程序也都直接放在快盘里，方便同步。
于是乎，马上注册体验。&lt;/p&gt;

&lt;p&gt;不过现在还是发现有些不怎么爽的地方，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;无法本地预览文章
同步不够及时（即使我手动访问了同步链接）
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Git rebase小计(转)</title>
   <link href="//2013/02/05/git-rebase.html"/>
   <updated>2013-02-05T00:00:00+08:00</updated>
   <id>/2013/02/05/git-rebase</id>
   <content type="html">&lt;p&gt;git rebase，顾名思义，就是重新定义（re）起点（base）的作用，即重新定义分支的版本库状态。要搞清楚这个东西，要先看看版本库状态切换的两种情况：&lt;/p&gt;

&lt;p&gt;我们知道，在某个分支上，我们可以通过git reset，实现将当前分支切换到本分支以前的任何一个版本状态，即所谓的“回溯”。即实现了本分支的“后悔药”。也即版本控制系统的初衷。&lt;/p&gt;

&lt;p&gt;还有另一种情况，当我们的项目有多个分支的时候。我们除了在本地开发的时候可能会“回溯”外，也常常会将和自己并行开发的别人的分支修改添加到自 己本地来。这种情况下很常见。作为项目管理员，肯定会不断的合并各个子项目的补丁，并将最新版本推送到公共版本库，而作为开发人员之一，提交自己的补丁之 后，往往需要将自己的工作更新到最新的版本库，也就是说把别的分支的工作包含进来。&lt;/p&gt;

&lt;p&gt;举个例子来说吧！
假设我们的项目初期只有一个master分支，然后分支上作过两次提交。这个时候系统只有一个master分支，他的分支历史如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master0（初始化后的版本）
||
v
master1（第一次提交后的版本）
||
v
master2（第二次提交后的版本）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，我们可以&lt;strong&gt;通过git reset将master分支&lt;/strong&gt;（工作目录、工作缓存或者是版本库）切换到master1或者master0版本，这就是前面所说的第一种情况。
假设我们这里把master分支通过git reset回溯到了master1状态。那么这个时候系统仍然只有一个master分支，分支的历史如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master0（初始化后的版本）
||
v
master1（第一次提交后的版本）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们在这里以master1为起点，创建了另一个分支test。那么对于test分支来说，他的第一个版本test0就和master1是同一个版本，此时项目的分支历史如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master0（初始化后的版本）
||
v
master1（第一次提交后的版本）===test0（test分支，初始化自master分支master1状态）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，我们分别对master分支、test分支作两次提交，此时版本库应该成了这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master0（初始化后的版本）
||
v
master1===test0==&amp;gt;test1===&amp;gt;test2
||
v
master2===&amp;gt;master3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，通过第一种git reset的方式，可以将master分支的当前状态（master3）回溯到master分支的master0、master1、master2状态。 也可已将test分支当前状态（test2）回溯到test分支的test0、test1状态，以及test分支的父分支master的master0、 master1状态。&lt;/p&gt;

&lt;p&gt;那么。如果我要让test分支从test0到test2之间所有的改变都添加到master分支来，使得master分支包含test分支的所有修改。这个时候就要用到git rebase了。&lt;/p&gt;

&lt;p&gt;首先，我们切换到master分支，然后运行下面的命令，即可实现我们的要求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;这个时候，git做了些什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;先将test分支的代码checkout出来，作为工作目录
然后将master分支从test分支创建起的所有改变的补丁，依次打上。如果打补丁的过程没问题，rebase就搞定了

如果打补丁的时候出现了问题，就会提示你处理冲突。处理好了，可以运行git rebase –continue继续直到完成

如果你不想处理，你还是有两个选择，一个是放弃rebase过程（运行git rebase –abort），另一个是直接用test分支的取代当前分支的（git rebase –skip）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，rebase还能够让你修订以前提交，这个功能日后再说。&lt;/p&gt;

&lt;p&gt;=======================================&lt;/p&gt;

&lt;p&gt;另外，使用git rebase不要滥用，否则会比较麻烦，需要注意的地方参考下面这篇：
&lt;a href=&quot;http://blog.csdn.net/jixiuffff/article/details/5970891&quot;&gt;git 关于merge rebase(衍合)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;转自：
&lt;a href=&quot;http://www.cnblogs.com/kym/archive/2010/08/12/1797937.html&quot;&gt;http://www.cnblogs.com/kym/archive/2010/08/12/1797937.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考：
&lt;a href=&quot;http://ihower.tw/blog/archives/3843/&quot;&gt;使用 git rebase 避免無謂的 merge&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/jixiuffff/article/details/5970891&quot;&gt;git 关于merge rebase(衍合)&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>